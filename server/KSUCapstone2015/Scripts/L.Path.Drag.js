/**
 * Matrix transform path for SVG/VML
 * TODO: adapt to Leaflet 0.8 upon release
 */

"use strict";

if (L.Browser.svg) { // SVG transformation

    L.Path.include({

        /**
         * Reset transform matrix
         */
        _resetTransform: function () {
            this._container.setAttributeNS(null, 'transform', '');
        },

        /**
         * Applies matrix transformation to SVG
         * @param {Array.<Number>} matrix
         */
        _applyTransform: function (matrix) {
            this._container.setAttributeNS(null, "transform",
              'matrix(' + matrix.join(' ') + ')');
        }

    });

} else { // VML transform routines

    L.Path.include({

        /**
         * Reset transform matrix
         */
        _resetTransform: function () {
            if (this._skew) {
                // super important! workaround for a 'jumping' glitch:
                // disable transform before removing it
                this._skew.on = false;
                this._container.removeChild(this._skew);
                this._skew = null;
            }
        },

        /**
         * Applies matrix transformation to VML
         * @param {Array.<Number>} matrix
         */
        _applyTransform: function (matrix) {
            var skew = this._skew;

            if (!skew) {
                skew = this._createElement('skew');
                this._container.appendChild(skew);
                skew.style.behavior = 'url(#default#VML)';
                this._skew = skew;
            }

            // handle skew/translate separately, cause it's broken
            var mt = matrix[0].toFixed(8) + " " + matrix[1].toFixed(8) + " " +
              matrix[2].toFixed(8) + " " + matrix[3].toFixed(8) + " 0 0";
            var offset = Math.floor(matrix[4]).toFixed() + ", " +
              Math.floor(matrix[5]).toFixed() + "";

            var s = this._container.style;
            var l = parseFloat(s.left);
            var t = parseFloat(s.top);
            var w = parseFloat(s.width);
            var h = parseFloat(s.height);

            if (isNaN(l)) l = 0;
            if (isNaN(t)) t = 0;
            if (isNaN(w) || !w) w = 1;
            if (isNaN(h) || !h) h = 1;

            var origin = (-l / w - 0.5).toFixed(8) + " " + (-t / h - 0.5).toFixed(8);

            skew.on = "f";
            skew.matrix = mt;
            skew.origin = origin;
            skew.offset = offset;
            skew.on = true;
        }

    });
}

// Renderer-independent
L.Path.include({

    /**
     * Check if the feature was dragged, that'll supress the click event
     * on mouseup. That fixes popups for example
     *
     * @param  {MouseEvent} e
     */
    _onMouseClick: function (e) {
        if ((this.dragging && this.dragging.moved()) ||
          (this._map.dragging && this._map.dragging.moved())) {
            return;
        }

        this._fireMouseEvent(e);
    }
});
/**
 * Leaflet vector features drag functionality
 * @preserve
 */

"use strict";

/**
 * Drag handler
 * @class L.Path.Drag
 * @extends {L.Handler}
 */
L.Handler.PathDrag = L.Handler.extend( /** @lends  L.Path.Drag.prototype */ {

    /**
     * @param  {L.Path} path
     * @constructor
     */
    initialize: function (path) {

        /**
         * @type {L.Path}
         */
        this._path = path;

        /**
         * @type {Array.<Number>}
         */
        this._matrix = null;

        /**
         * @type {L.Point}
         */
        this._startPoint = null;

        /**
         * @type {L.Point}
         */
        this._dragStartPoint = null;

    },

    /**
     * Enable dragging
     */
    addHooks: function () {
        this._path.on('mousedown', this._onDragStart, this);
        if (!L.Path.CANVAS) {
            L.DomUtil.addClass(this._path._container, 'leaflet-path-draggable');
        }
    },

    /**
     * Disable dragging
     */
    removeHooks: function () {
        this._path.off('mousedown', this._onDragStart, this);
        if (!L.Path.CANVAS) {
            L.DomUtil.removeClass(this._path._container, 'leaflet-path-draggable');
        }
    },

    /**
     * @return {Boolean}
     */
    moved: function () {
        return this._path._dragMoved;
    },

    /**
     * Start drag
     * @param  {L.MouseEvent} evt
     */
    _onDragStart: function (evt) {
        this._startPoint = evt.containerPoint.clone();
        this._dragStartPoint = evt.containerPoint.clone();
        this._matrix = [1, 0, 0, 1, 0, 0];

        this._path._map
          .on('mousemove', this._onDrag, this)
          .on('mouseup', this._onDragEnd, this)
        this._path._dragMoved = false;
    },

    /**
     * Dragging
     * @param  {L.MouseEvent} evt
     */
    _onDrag: function (evt) {
        var x = evt.containerPoint.x;
        var y = evt.containerPoint.y;

        var dx = x - this._startPoint.x;
        var dy = y - this._startPoint.y;

        if (!this._path._dragMoved && (dx || dy)) {
            this._path._dragMoved = true;
            this._path.fire('dragstart');

            if (this._path._popup) {
                this._path._popup._close();
                this._path.off('click', this._path._openPopup, this._path);
            }
        }

        this._matrix[4] += dx;
        this._matrix[5] += dy;

        this._startPoint.x = x;
        this._startPoint.y = y;

        this._path._applyTransform(this._matrix);
        this._path.fire('drag');
        L.DomEvent.stop(evt.originalEvent);
    },

    /**
     * Dragging stopped, apply
     * @param  {L.MouseEvent} evt
     */
    _onDragEnd: function (evt) {
        L.DomEvent.stop(evt);
        // undo container transform
        this._path._resetTransform();
        // apply matrix
        this._transformPoints(this._matrix);

        this._path._map
          .off('mousemove', this._onDrag, this)
          .off('mouseup', this._onDragEnd, this);

        // consistency
        this._path.fire('dragend', {
            distance: Math.sqrt(
              L.LineUtil._sqDist(this._dragStartPoint, evt.containerPoint)
            )
        });

        if (this._path._popup) {
            L.Util.requestAnimFrame(function () {
                this._path.on('click', this._path._openPopup, this._path);
            }, this);
        }

        this._matrix = null;
        this._startPoint = null;
        this._dragStartPoint = null;
        this._path._dragMoved = false;
    },

    /**
     * Applies transformation, does it in one sweep for performance,
     * so don't be surprised about the code repetition.
     *
     * [ x ]   [ a  b  tx ] [ x ]   [ a * x + b * y + tx ]
     * [ y ] = [ c  d  ty ] [ y ] = [ c * x + d * y + ty ]
     *
     * @param {Array.<Number>} matrix
     */
    _transformPoints: function (matrix) {
        var path = this._path;
        var i, len, latlng;

        var px = L.point(matrix[4], matrix[5]);

        var crs = path._map.options.crs;
        var transformation = crs.transformation;
        var scale = crs.scale(path._map.getZoom());
        var projection = crs.projection;

        var diff = transformation.untransform(px, scale)
          .subtract(transformation.untransform(L.point(0, 0), scale));

        // console.time('transform');

        // all shifts are in-place
        if (path._point) { // L.Circle
            path._latlng = projection.unproject(
              projection.project(path._latlng)._add(diff));
            path._point._add(px);
        } else if (path._originalPoints) { // everything else
            for (i = 0, len = path._originalPoints.length; i < len; i++) {
                latlng = path._latlngs[i];
                path._latlngs[i] = projection
                  .unproject(projection.project(latlng)._add(diff));
                path._originalPoints[i]._add(px);
            }
        }

        // holes operations
        if (path._holes) {
            for (i = 0, len = path._holes.length; i < len; i++) {
                for (var j = 0, len2 = path._holes[i].length; j < len2; j++) {
                    latlng = path._holes[i][j];
                    path._holes[i][j] = projection
                      .unproject(projection.project(latlng)._add(diff));
                    path._holePoints[i][j]._add(px);
                }
            }
        }

        // console.timeEnd('transform');

        path._updatePath();
    }

});

L.Path.prototype.__initEvents = L.Path.prototype._initEvents;
L.Path.prototype._initEvents = function () {
    //this.__initEvents();

    if (this.options.draggable) {
        if (this.dragging) {
            this.dragging.enable();
        } else {
            this.dragging = new L.Handler.PathDrag(this);
            this.dragging.enable();
        }
    } else if (this.dragging) {
        this.dragging.disable();
    }
};
(function () {

    // listen and propagate dragstart on sub-layers
    L.FeatureGroup.EVENTS += ' dragstart';

    function wrapMethod(klasses, methodName, method) {
        for (var i = 0, len = klasses.length; i < len; i++) {
            var klass = klasses[i];
            klass.prototype['_' + methodName] = klass.prototype[methodName];
            klass.prototype[methodName] = method;
        }
    }

    /**
     * @param {L.Polygon|L.Polyline} layer
     * @return {L.MultiPolygon|L.MultiPolyline}
     */
    function addLayer(layer) {
        if (this.hasLayer(layer)) {
            return this;
        }
        layer
          .on('drag', this._onDrag, this)
          .on('dragend', this._onDragEnd, this);
        return this._addLayer.call(this, layer);
    }

    /**
     * @param  {L.Polygon|L.Polyline} layer
     * @return {L.MultiPolygon|L.MultiPolyline}
     */
    function removeLayer(layer) {
        if (!this.hasLayer(layer)) {
            return this;
        }
        layer
          .off('drag', this._onDrag, this)
          .off('dragend', this._onDragEnd, this);
        return this._removeLayer.call(this, layer);
    }

    // duck-type methods to listen to the drag events
    wrapMethod([L.MultiPolygon, L.MultiPolyline], 'addLayer', addLayer);
    wrapMethod([L.MultiPolygon, L.MultiPolyline], 'removeLayer', removeLayer);

    var dragMethods = {
        _onDrag: function (evt) {
            var layer = evt.target;
            this.eachLayer(function (otherLayer) {
                if (otherLayer !== layer) {
                    otherLayer._applyTransform(layer.dragging._matrix);
                }
            });

            this._propagateEvent(evt);
        },

        _onDragEnd: function (evt) {
            var layer = evt.target;

            this.eachLayer(function (otherLayer) {
                if (otherLayer !== layer) {
                    otherLayer._resetTransform();
                    otherLayer.dragging._transformPoints(layer.dragging._matrix);
                }
            });

            this._propagateEvent(evt);
        }
    };

    L.MultiPolygon.include(dragMethods);
    L.MultiPolyline.include(dragMethods);

})();